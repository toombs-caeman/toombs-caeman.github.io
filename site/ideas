<!DOCTYPE html><html lang="en"><meta charset="utf-8"><title>Ideas</title><link href="/site/min.css" rel="stylesheet" type="text/css"><link href="/site/feed.xml" rel="alternate" type="application/rss+xml"><link href="/static/favicon.jpg" rel="shortcut icon" type=image/x-icon"><!-- TODO title></!--></!--><div class="page-content">    post/project ideas<p>
<ul><li>depth of learning
<ul><li>let this repo be the 'textbook' level, with full research, external links, and more powerful, computer-aided data manipulations<li>let the notebook be more of a work in progress, include some personalizations<li>make the esoterica for the final version, fully personalized<li>internal memory is based on esoterica</ul><li>journey - method of loci<li>explicit theory<li>theory of mind / theory of learning<li>memory<li>mechanical reasoning <a href="https://en.wikipedia.org/wiki/TRIZ">https://en.wikipedia.org/wiki/TRIZ</a>
<ul><li>the tricky part of seeing the beauty of mathematical proof is knowing enough to know which parts are mechanical thought
        and which are leaps of insight<li>by automatically generating links between related ideas with no assistance from a human, a computer can suggest previously unknown associations
        </ul><li>A <a href="https://web.stanford.edu/~engler/tickc.pdf">tcc</a> <a href="http://canonical.org/~kragen/bytebeat/">bytebeat</a> interpreter/sample generator<li>treadmill problem - given that the human senses are all limited by an <a href="https://en.wikipedia.org/wiki/Absolute_threshold">absolute threshold</a>
    some small force could be applied to the body which would be guaranteed to be unnoticeable.
    Additionally, there is a maximum force that the human body can exert.
    If we built an omni-directional treadmill (or equivalent harness for 3d), which accelerated below that threshold in
    order to dynamically keep it's user in the center, that would lay the framework for effectively infinite/boundaryless
    virtual spaces (since in all cases the 'corrective' force applied to the user would be undetectable).
<ul><li>Given that these limits exist, how large does the treadmill need to be?<li>The max force limit depends on the max speed being finite and small, so simulated vehicles might be problematic, though
        relative force perception sensitivity decreases as absolute force increases, so perhaps this could be fudged.<li>the treadmill will essentially need to run some sort of <a href="https://en.wikipedia.org/wiki/PID_controller">PID</a> loop based on the users location.</ul><li>trilateration problem - might be more readable with <a href="https://github.com/KaTeX/KaTeX">KaTeX</a>.<li><a href="https://www.youtube.com/watch?v=cyW5z-M2yzw">discordant</a> <a href="https://en.wikipedia.org/wiki/Hausdorff_dimension">fractals</a>.
    Does harmony have a visual analog in fractals, or do fractals with Hausdorff dimensions close to simple fractions
    appear more orderly or aesthetic? Is there a way to generate diverse fractals with a specific hausdorff dimension?<li>can an EEG placed on the back of the neck do eye tracking based on detecting unconscious neck muscle twitches that correlate to eye movement?
    This could offer a way to do eye tracking 'in the field' where you don't have anything obstructing the field of view.
    If combined with a body cam, can you accurately locate the gaze on objects in the environment?
    search cervico-ocular reflex</ul>
<p>
<ul><li>areas of (possibly ad hoc) computer research/development that most things fall into.
<ul><li>algorithmic - applied math. How can computers do things correctly and efficiently?<li>ergonomic - how can the language/tools/etc we use be more expressive/powerful/high-level/transparent/learnable
        and help us avoid pitfalls.
<ul><li>whereas algorithms can be as esoteric and complicated as they need to be, the tools we use cannot be because we are only human.
            It must be possible to package performance code into a library with a relatively simple interface so that
            most people won't have to interact with that complexity most of the time.<li>all (most) of the effort being put into new languages (or the constant rotation of new javascript frameworks) belongs here.</ul><li>hardware - applied physics. how do we put lightning in a bottle?<li>legal - licensing, right to privacy, right to repair, ethical hacking,<li>social - how do you manage a project? How do you manage project lifetimes, or attract maintainers? codes of conduct?
        diversity and inclusion?<li>domain understanding - understanding a clients needs well enough to represent domain specific knowledge in a program.</ul></ul>
<p>
<ul><li>there are a few classes of problems in computer science and engineering that get solved repeatedly in adhoc ways.
<ul><li>The huge prevalence of copypasta code is a testament to the failure to capture complexity in a library.<li>can we use stats on copied code from StackOverflow as a way to design libraries/languages and better cover common complexity?</ul></ul>
<p>
<ul><li>there's a very important class of computation that translates one set of symbols into another, sometimes called compiling or compilation.
<ul><li>we can think of compiling abstractly as a translation (reversible or lossy) of a structured set of symbols into another.<li>The elements of the input don't necessarily need to be from the same set as elements in the output, nor does their structure (list, tree, etc) need to be the same.<li>my point is that there is a structural similarity between json-munging and compilers, between Terraform and LLVM.
<ul><li>Perhaps this structure could be exploited to propagate optimizations up and down the tech stack (manually).
            What can compiler developers learn from web developers, and vice versa?<li>Perhaps also this could be used to define a 'core' compute engine that self-optimizes (self-compiles?) based on properties
            of the input and output  <a href="https://en.wikipedia.org/wiki/Category_theory">languages</a>, but is capable of running
            in a number of environments (bare metal, posix, JVM, etc.)<li>could we describe the various instruction sets and the translations between them in a unified, rigorous way?
            all the way through logic gates -> x86 -> system calls -> JVM -> javascript. Could a monolithic 'compiler'
            understand how to optimize in each of these contexts?</ul><li>example applications:
<ul><li>compiling typescript to javascript<li>compiling javascript to bye code<li>generating configuration on the fly (aka turing complete wrappers for inept 'no code' tools)<li>translating between human languages<li>parsing a string into json<li>data normalization in general</ul></ul></ul>
<p>
<ul><li>the study of magic and magical thinking is useful because people turn towards alternative solutions when
<ul><li>they can't or haven't been able to formulate the issue they're facing distinctly enough to address it directly<li>there isn't an accepted/comprehensible/workable solution to the problems they face<li>the magic works in some sense, though not necessarily through the proposed mechanisms.
        Most likely for psychological or social issues.<li>in all cases</ul></ul>
<p>
<ul><li>tulpa/rapscallion/servitor
<ul><li>https://en.wikipedia.org/wiki/Tulpa<li>https://tulpanomicon.guide/
    </ul><li>the point of metaphysics isn't truth but ease of reasoning about physics
<ul><li>this is why occam's razor is so powerful<li>given two models that 'effectively' give the same predictions, using the one that requires less computation
        allows us to predict more. and is therefore more pragmatic<li>it isn't just about getting the right answer, but also doing so in time, with our limited brains<li>once we move beyond the edge of where we can effectively find a 'correct' answer (which isn't very far)
        we need to consider answers which instead have desirable consequences
        (desirable here being subjective, and subject to manipulation)<li>occam's razor then gives us a tool by which we can reason about belief.<li>complex metaphysics are less performant and so would naturally be selected against (memetics) unless they had a hidden benefit.
</div></ul></ul>
<p><p><hr><p><!-- TODO tag filters></!--></!-->
<ul><li><a href="/site/ideas">Ideas</a></ul>
<p><hr><p><footer><div style=text-align:center>    <a href="https://webring.xxiivv.com/#random"><img class="icon" src="https://webring.xxiivv.com/icon.black.svg" alt="xxiivv webring" title="xxiivv webring"></a>    <a href="https://github.com/toombs-caeman"><img class="icon" src="/static/github.svg" alt="github" title="github"></a><!--<a href="mailto:toombs.caeman@gmail.com"><img class="icon" src="/static/mail.svg" alt="email" title="email"></a>--></div>created 2021-07-09</footer><p><p>